;; CRITICAL COMPLEX GENERATED BY A DISCRETE VECTOR FIELD





;; We need to implement a critical-complex-basis function that takes as input an algebraic cellular
;; complex and an admissible discrete vector field an returns its associated V-chain complex.


;;BASIS

(defun aux-basis-dvf (vf lista n)
              (if (eq (length lista) 0)
                  nil
                (if (eq (length lista) 1)
                    (if (ev-status-vctr (funcall vf n (first lista)) :crtc)
                        lista
                      nil)
                  (let*(
                        (flista (first lista))
                        (rlista (rest lista)))
                    (if (ev-status-vctr (funcall vf n flista) :crtc)
                       (cons flista (aux-basis-dvf vf rlista n))
                      (aux-basis-dvf vf rlista n))))))


(defun crtc-complex-basis (cc vf)
               (declare (type chain-complex cc))
               (declare (type vector-field vf))
               (when (eq (basis cc) :locally-effective)
                 (return-from crtc-complex-basis :locally-efective))
               (flet ((rslt (degr)
                            (declare (type fixnum degr))
                            (let*(
                                  (lista (funcall (basis cc) degr)))
                              (aux-basis-dvf vf lista degr))))
                 #'rslt))


;;DIFFERENTIAL



(defun aux-filter-dvf (list-of-lists vf n status)
               (if (eq (length list-of-lists) 0)
                   nil
                 (if (eq (length list-of-lists) 1)
                     (if (ev-status-vctr (funcall vf n (rest (first list-of-lists))) status)
                         list-of-lists
                       nil)
                   (let*(
                         (flol (first list-of-lists))
                         (rlol (rest list-of-lists)))
                     (if (ev-status-vctr (funcall vf n (rest (first list-of-lists))) status)
                         (cons flol (aux-filter-dvf rlol vf n status))
                       (aux-filter-dvf rlol vf n status))))))

;; critical --> critical component

(defun diff-cc (cc vf)
               (declare (type chain-complex cc))
               (declare (type vector-field vf))
               (flet ((rslt (degr gnrt)
                            (declare (type fixnum degr))
                            (if (eq degr 0)
                                (zero-cmbn -1)
                            (let*(
                                  (combination-diff (dffr cc degr gnrt))
                                  (lol (cmbn-list combination-diff))
                                  (lol-c (aux-filter-dvf lol vf (- degr 1) :crtc)))
                              (make-cmbn
                               :degr (- degr 1)
                               :list lol-c)))))
                 #'rslt))

;; critical --> source component


(defun diff-cs (cc vf)
               (declare (type chain-complex cc))
               (declare (type vector-field vf))
               (flet ((rslt (degr gnrt)
                            (declare (type fixnum degr))
                            (if (eq degr 0)
                                (zero-cmbn -1)
                              (let*(
                                    (combination-diff (dffr cc degr gnrt))
                                    (lol (cmbn-list combination-diff))
                                    (lol-c (aux-filter-dvf lol vf (- degr 1) :sorc)))
                                (make-cmbn
                                 :degr (- degr 1)
                                 :list lol-c)))))
                 #'rslt))



(defun diff-cstc (cc vf)
              (declare (type chain-complex cc))
              (declare (type vector-field vf))
              (flet ((rslt (degr gnrt)
                           (if (eq degr 0)
                               (zero-cmbn -1)
                             (let*(
                                   (h-vf (chcm-vf-reduction-h cc vf))
                                   (pre-cmbn (n-cmbn -1 (dffr cc (? h-vf (funcall (diff-cs cc vf) degr gnrt)))))
                                   (lista-pre-cmbn (cmbn-list pre-cmbn)))
                               (make-cmbn
                                :degr (- degr 1)
                                :list (aux-filter-dvf lista-pre-cmbn vf (- degr 1) :crtc))))))
               #'rslt))


(defun crtc-complex-dffr (cc vf)
               (declare (type chain-complex cc))
               (declare (type vector-field vf))
               (flet ((rslt (degr gnrt)
                            (let*(
                                  (dcc-component (funcall (diff-cc cc vf) degr gnrt))
                                  (dsc-component (funcall (diff-cstc cc vf) degr gnrt)))
                              (2cmbn-add (cmpr cc) dcc-component dsc-component))
                            ))
                 #'rslt))

;; CMPR
;; It should be the same as the original chain complex.



;; BSPN
;; It may not be the same as the original chain complex, so we take the first critical 0-simplex.

(defun crtc-complex-bspn (cc vf)
               (declare (type chain-complex cc))
               (declare (type vector-field vf))
               (first (funcall (crtc-complex-basis cc vf) 0)))







;; CRITICAL COMPLEX


(defun critical-complex (cc vf)
               (declare (type chain-complex cc))
               (declare (type vector-field vf))
               (build-chcm
                :cmpr (cmpr cc)
                :basis (crtc-complex-basis cc vf)
                :bsgn (crtc-complex-bspn cc vf)
                :intr-dffr (crtc-complex-dffr cc vf)
                :strt :gnrt 
                :orgn `(critical complex generated by ,cc and ,vf)))







;; REDUCTION CC ==> CC^c

;; g-map

(defun map-id-stc (cc vf)
              (declare (type chain-complex cc))
              (declare (type vector-field vf))
              (flet((rslt (degr gnrt)
                          (if (eq degr 0)
                              (term-cmbn degr 1 gnrt)
                          (let*(
                                (h-vf (chcm-vf-reduction-h cc vf))
                                (pre-cmbn (n-cmbn -1 ( ? h-vf (funcall (diff-cs cc vf) degr gnrt))))
                                (lista-pre-cmbn (cmbn-list pre-cmbn))
                                (stc-cmbn (make-cmbn
                                           :degr degr
                                           :list lista-pre-cmbn ))
                                (id-cmbn (term-cmbn degr 1 gnrt)))
                            (2cmbn-add (cmpr cc) stc-cmbn id-cmbn)))))
                #'rslt))
                            

(defun g-vf-reduction (cc vf)
              (declare (type chain-complex cc))
              (declare (type vector-field vf))
              (build-mrph 
               :sorc (critical-complex cc vf)
               :trgt cc
               :degr 0
               :intr (map-id-stc cc vf)
               :strt :gnrt
               :orgn `(g map ,vf reduction over ,cc)))


;; f-map

(defun aux-f-map-vf (cc vf)
               (declare (type chain-complex cc))
               (declare (type vector-field vf))
               (flet((rslt (degr gnrt)
                           (let*(
                                 (gnrt-status (stts (funcall vf degr gnrt))))
                             (case gnrt-status
                               (:trgt (zero-cmbn degr))
                               (:crtc (term-cmbn degr 1 gnrt))
                               (:sorc 
                                (let*(
                                      (h-vf (chcm-vf-reduction-h cc vf))
                                      (pre-cmbn (n-cmbn -1 (? h-vf degr gnrt)))
                                      (lista-pre-cmbn (cmbn-list pre-cmbn)))
                                  (make-cmbn
                                   :degr degr
                                   :list (aux-filter-dvf lista-pre-cmbn vf degr :crtc))))))))
                 #'rslt))


(defun f-vf-reduction (cc vf)
              (declare (type chain-complex cc))
              (declare (type vector-field vf))
              (build-mrph 
               :sorc cc
               :trgt (critical-complex cc vf)
               :degr 0
               :intr (aux-f-map-vf cc vf)
               :strt :gnrt
               :orgn `(f map of ,vf reduction over ,cc)))


;; Reduction

(defun vf-reduction (cc vf)
               (declare (type chain-complex cc))
               (declare (type vector-field vf))
               (build-rdct
                :f (f-vf-reduction cc vf)
                :g (g-vf-reduction cc vf)
                :h (chcm-vf-reduction-h cc vf)
                :orgn `(reduction of ,vf over ,cc)))


;; Example
#|

;; we first define our chain complex.

(setf example-cmpr #'s-cmpr)
(setf example-basis #'(lambda (dmn)
                                     (case dmn
                                       (0 '(a b c d e))
                                       (1 '(ab ac bc cd ce de))
                                       (2 '(abc))
                                       (otherwise nil))))


(setf example-bspn 'a)
(setf example-pure-dffr 
               #'(lambda (dmn gnr)
                   (unless (<= 0 dmn 2)
                     (error "Non-correct dimension for the example."))
                   (case dmn
                     (0 (cmbn -1))
                     (1 (case gnr
                          (ab (cmbn 0 -1 'a 1 'b))
                          (ac (cmbn 0 -1 'a 1 'c))
                          (bc (cmbn 0 -1 'b 1 'c))
                          (cd (cmbn 0 -1 'c 1 'd))
                          (ce (cmbn 0 -1 'c 1 'e))
                          (de (cmbn 0 -1 'd 1 'e))))
                     (2 (case gnr
                          (abc (cmbn 1 1 'ab -1 'ac 1 'bc))))
                     (otherwise (error "Bad generators for the example.")))))
(setf example-strt :gnrt)
(setf example-orgn '(example))
(setf example (build-chcm :cmpr example-cmpr :basis example-basis 
                                       :bsgn example-bspn :intr-dffr example-pure-dffr
                                       :strt example-strt :orgn example-orgn))



;; And a discrete vector field over it.

(setf example-dvf #'(lambda (dmn gnr)
                                   (unless (<= 0 dmn 2)
                                     (error "Non-correct dimension for the example."))
                                   (case dmn
                                     (0 (case gnr
                                          (a (vctr :sorc 'ac -1))
                                          (b (vctr :sorc 'ab  1))
                                          (c (vctr :crtc))
                                          (d (vctr :sorc 'de -1))
                                          (e (vctr :sorc 'ce  1))))
                                     (1 (case gnr
                                          (ab (vctr :trgt 'b  1))
                                          (ac (vctr :trgt 'a -1))
                                          (bc (vctr :sorc 'abc 1))
                                          (cd (vctr :crtc))
                                          (ce (vctr :trgt 'e 1))
                                          (de (vctr :trgt 'd -1))))
                                     (2 (case gnr
                                          (abc (vctr :trgt 'bc 1))))
                                     (otherwise (error "Bad generators for the example.")))))


|#




